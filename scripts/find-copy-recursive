#!/bin/bash -e

# Filename: find-copy-recursive
# Purpose:  Recursively copy files based on find results
# Author:   Lex Sheehan
# License:  MIT

Usage() 
{
	echo "
Usage: $(basename $0) <--to-dir to_dir> <FIND_COMMAND_PARAMETERS>

Options:
	-t or --to-dir:  <Required> directory name to copy files to

Examples:
$(basename $0) --to-dir ~/tmp/testdir . -type f -name \"*123*\"
"
}

Parse_arguments() 
{
	if [ "${DEBUG}" == "true" ]; then
		echo "++ $(basename $0) $@"
	fi
	
	while [ $# -gt 0 ]; do
		case $1 in
			--help)
				HELPINFO=true;;
			--to-dir | -t)
                shift
				TO_DIR="$1"
				return;;
		esac
		shift
	done
}
# Set default values; leave empty if you want user to specify its value.
TO_DIR=
Parse_arguments $@

if [ "${TO_DIR}" == "" ]; then
	echo "Missing required parameter: TO_DIR"
	Usage;exit 2
fi

if [ "${HELPINFO}" == "true" ]; then
    Usage;exit 0
fi

# MAIN
# The following could work for renaming files as long as no subdirectories have the search string its name
# https://stackoverflow.com/questions/9393607/find-and-replace-filename-recursively-in-a-directory

while read line
do
	echo "> $line"
	if [ -d "$line" ]; then
		source_dir="$(dirname $line)"
		mkdir -p "$TO_DIR/$source_dir"
	elif [[ "$line" == *"/"* ]]; then
		source_dir="$(dirname $line)"
		mkdir -p "$TO_DIR/$source_dir"
		cp "$line" "$TO_DIR/$source_dir"
	else
		cp "$line" $TO_DIR
	fi
done < <(eval "find $(orig_string="${@:2} ";left_string="${orig_string// \*/ \"*}";echo "${left_string//\* /\*\" }")") 
